<!-- markdownlint-disable MD013 -->

# Git LFS: Overview, Health Check, and Best Practices

This document provides:

- A quick health check in this repository (is Git LFS installed? enabled?).
- A primer on why and how to use Git LFS.
- Guidance on which files should or should not be tracked.
- Recommended next steps for this repository.
- A brief TL;DR summary.

## 1. Health Check: Git LFS Status in This Repository

### 1.1. Git LFS Client Installation

Run:

```bash
git lfs version
```

Output example:

```bash
git-lfs/3.6.1 (GitHub; linux amd64; go 1.23.4)
```

**Result:** Git LFS is installed locally.

### 1.2. Repository LFS Tracking Configuration

Check for a `.gitattributes` file at the repo root:

```bash
test -f .gitattributes && echo "exists" || echo "no .gitattributes at repo root"
```

**Result:** No `.gitattributes` found ⇒ no LFS patterns configured.

Check which files (if any) are already tracked by LFS:

```bash
git lfs ls-files
```

**Result:** List of PNG/JPG assets currently tracked in LFS.

## 2. Git LFS Primer: Why and How

### 2.1. Why Use Git LFS

By default, Git stores every version of every file in its database. Large binary files (images, audio, video, archives,
datasets, etc.) bloat the repository and slow down clones and checkouts. Git LFS stores large files on a separate
server and keeps lightweight pointers in Git.

### 2.2. Basic Setup Steps

1. Enable Git LFS hooks (once per clone):
   
   ```bash
   git lfs install
   ```

2. Track the desired file patterns (e.g., PSD and MP4):

   ```bash
   git lfs track "*.psd"
   git lfs track "*.mp4"
   ```

3. Commit the generated `.gitattributes`:

   ```bash
   git add .gitattributes
   git commit -m "chore: track PSD and MP4 files via LFS"
   git push
   ```

After this, new or modified matching files use LFS automatically.

## 3. Choosing Which Files to Track in LFS

### 3.1. Good Candidates for LFS

| File type / scenario                                       | Why                                            |
| ---------------------------------------------------------- | ---------------------------------------------- |
| **Large binaries** (images, audio, video, PSD, AI, etc.)   | Huge, non‑diffable, and bloat standard Git      |
| **ML models, checkpoints, datasets** (>10 MB)              | Full‑file overwrites, rarely diffable          |
| **Compressed archives** (ZIP, TAR)                         | Large blobs, few diffs                         |
| **Database dumps, large logs, scientific data files**      | Binary blobs, not human‑readable               |

### 3.2. Poor Candidates for LFS

| File type / scenario                               | Why                                          |
| -------------------------------------------------- | --------------------------------------------- |
| **Source code** (JS/TS/Python/Go/Java/etc.)         | Text, diffable, small                        |
| **Config files, docs, markdown, schemas**          | Text‑based, valuable diffs                   |
| **Small images/icons** (<0.5 MB)                   | Pointer overhead > file size                 |
| **Files changing frequently in small ways**         | Lose granular history, diffs in pointers only |

## 4. Next Steps for This Repository

1. Decide which large assets truly need LFS.
2. Run `git lfs install` (once) and then `git lfs track "<pattern>"` for chosen assets.
3. Commit and push the new `.gitattributes`.
4. If small files ended up in LFS by mistake, update `.gitattributes` and consider using
   `git lfs migrate` to clean up history.
5. Monitor GitHub LFS quotas and prune unneeded large binaries.

## 5. TL;DR

- Install/enable LFS: `git lfs install`.
- Track multi‑MB binaries via `git lfs track …`.
- Commit `.gitattributes`, then `git push`.
- Keep code and small text files in normal Git.
- Use LFS only for large, non‑diffable assets.


***

*Generated by running a health check and primer as of $(date)*
