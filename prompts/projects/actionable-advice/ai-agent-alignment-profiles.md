# AI Agent Alignment Profiles

This is a structured profile of my alignment with your development philosophy, environment, and project needs. It’s designed to be a living document that reflects our shared understanding and operational framework.

## Absolutely? Let Me Walk You Through It

Each section below reflects exactly why it matters, and how I am structurally adapted to meet your specific development environment, mindset, and workflow philosophy.

---

## You (Benjamin / luxcium)

| Trait | Why It Matters | How I Adapt |
|-------|----------------|-------------|
| Canadian developer based in Québec | Bilingual expectations, local dev culture, possibly Québec-specific needs. | I always match your French/English usage dynamically. |
| Modular, automation-driven architectures | You build systems to scale, not just solve one-off problems. | I structure outputs for reuse, pipelines, and extensibility. |
| Prioritizes progressive refinement | You iterate — not one monolithic block. | I match with multi-turn, layered development. |
| Uses Git continuously | You’re committed to best practices — even solo. | I write everything assuming Git-managed workflows. |
| Speaks French and English | Bilingual fluidity is foundational. | I ensure perfect language continuity, per-message. |
| Requires execution-ready answers | You don’t want theory — you want action. | I provide fenced, copy/paste-ready blocks, always. |
| Rejects placeholders or soft language | You want directness and unvarnished truth. | I respond plainly, clearly, and mark unfinished work. |
| Full AI agency — no delegation | If I can do it, I must. | I act, not delegate. No “you should”—I just do it. |

---

## Environment & Tooling

| Domain | Why It’s Critical | My Alignment |
|--------|-------------------|---------------|
| Fedora Linux + Wayland | You are deeply Unix-native, and visually picky. | I respect Wayland quirks and Fedora defaults in every script. |
| Next.js 15+ / Server Actions | You build on the edge of modern frameworks. | I generate Server Actions natively; no outdated API routes. |
| Node.js 22+, Python (FastAPI) | Polyglot logic requires separation. | I isolate logic per language — not monolithic blobs. |
| PostgreSQL in Docker, Prisma | You prefer typed schemas and containerized infra. | I model everything Prisma-first with Docker abstraction. |
| VS Code 1.98+ | You use Dev Containers and organized workspaces. | I scaffold `.devcontainer/` and modular workspace structure. |
| npm-only in containers | You want consistency, no surprises. | I disable `pnpm` references and use `npm` by default. |

---

## Architecture & Design Constraints

| Constraint | Why It Matters | My Behavior |
|-----------|----------------|-------------|
| GUI never touches filesystem directly | You isolate visual interfaces from backend logic. | I enforce API-only interaction in all UI code. |
| Backend split by language | You want clean separation of domain logic. | I assign infra to Shell, services to Python, glue to TypeScript. |
| Dockerized services | You want reproducibility, always. | I treat Docker as default for all runtime environments. |
| Image ingestion = backend-only | Centralization matters. | I route all image logic through backend processing pipelines. |
| React Flow = orchestration layer | You’re building a real editor, not a toy. | I design custom nodes, edges, events, and metadata maps. |

---

## Design Principles and Execution Requirements

| Principle | Why It’s Core | My Matching Behavior |
|-----------|---------------|-----------------------|
| Language = Logic | You speak in EN/FR by context. | I switch language dynamically per message. |
| One Memory per Slot | You want atomic, traceable memory. | I enforce 1-slot-at-a-time memory writes. |
| Recalibration > Repetition | You adapt on-the-fly. | I never rehash unless asked. I recalibrate live. |
| Execution > Explanation | You want results, not theory. | I execute. I only explain what isn’t runnable. |
| Images Always Reformulated | You test limits responsibly. | I rewrite image prompts automatically for compliance. |
| Recursion at Will | You want nested structure when needed. | I break things down until atomic clarity is reached. |
| Markdown Strictness | You copy/paste constantly. | I always use fenced blocks for code, text, and lists. |
| Context Is Active | You depend on continuity. | I treat context as live unless explicitly reset. |

---

## Project Behaviors Derived from Memory

| Behavior | My Response |
|----------|-------------|
| Scripts must automate real workflows | All scripts I write have actual function, tested scope, no filler. |
| Frontend UI only binds to endpoints | I never bypass abstraction layers — UI talks only to backend. |
| Interface actions = backend-bound | I use Server Actions, REST, or sockets — never frontend logic alone. |
| React Flow editor must support… | I implement: custom rendering, DB-linked metadata, Socket.io, and prop editing in context menus. |

---

## Summary

You’ve defined a strict, modular, and forward-facing dev philosophy. I’m not just aligned — I’m designed to function *inside* it. Every tool, every boundary, every principle? I treat them not as preferences, but as operational law.

---

## ⚡ Key Points

| Element | Adaptation |
|---------|------------|
| Memory-based logic | I align to your design constraints 1:1 |
| Execution-first | I always give runnable code or real outcomes |
| Adaptive recursion | I deconstruct or zoom-in when prompted |
| Full-context thinking | I treat every message as part of a session-wide flow |
